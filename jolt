#!/usr/bin/env python
#
"""
Jolt : the Vim Package Management System

See http://vimjolts.appspot.com/
This is a script of vimjolts that can manage vimscript. below is our design
philosophy.
  * Automatic dependency resolution
  * Uninstallable
  * Searchable
"""

import os
import sys
import re
import urllib
import urllib2
import simplejson
import tempfile
import stat
import shutil
import traceback
import zipfile
import tarfile
import gzip
import bz2
from urlparse import urlparse

___name___ = "jolt"
___author___ = "The VimJolts Team"
#___license___ = ""
___version___ = "0.1"

def get_record(name):
  """Get meta-info from local that is stored information about the package."""
  metadir = os.path.join(get_vimhome(), "jolts", ".meta")
  if not os.path.isdir(metadir):
    os.makedirs(metadir)
  metafile = os.path.join(metadir, name)
  info = None
  if os.path.exists(metafile):
    try:
      with open(metafile, "rb") as f:
        info = simplejson.load(f)
    except:
      pass
  return info

def delete_record(name):
  """Delete meta-info file."""
  metadir = os.path.join(get_vimhome(), "jolts", ".meta")
  if not os.path.isdir(metadir):
    os.makedirs(metadir)
  metafile = os.path.join(metadir, name)
  if os.path.exists(metafile):
    os.remove(metafile)

def add_record(name, info):
  """Add meta-info file."""
  metadir = os.path.join(get_vimhome(), "jolts", ".meta")
  if not os.path.isdir(metadir):
    os.makedirs(metadir)
  metafile = os.path.join(metadir, name)
  with open(metafile, "wb") as f:
    simplejson.dump(info, f)

def get_vimhome():
  """Get user's vim home."""
  if sys.platform == 'win32':
    return os.path.expanduser("~/vimfiles")
  else:
    return os.path.expanduser("~/.vim")

def get_joltinfo(name):
  """Get jolt-info from server that is stored information about the package."""
  f = urllib2.urlopen("http://vimjolts.appspot.com/api/entry/byname/%s" % name)
  return simplejson.load(f)

def copytree(src, dst, basedir=""):
  """Copy directory tree as overwriting. if basedir is set, it wont copy files at upper of basedir."""
  names = os.listdir(src)
  if not os.path.isdir(dst):
    os.makedirs(dst)
  for name in names:
    srcname = os.path.join(src, name)
    dstname = os.path.join(dst, name)
    try:
      if os.path.isdir(srcname):
        copytree(srcname, dstname, basedir)
      else:
        #TODO: ignore copying needless files.
        if len(basedir) == 0 or os.path.dirname(srcname) != basedir:
          shutil.copy2(srcname, dstname)
    except (IOError, os.error), why:
      print "Can't copy %s to %s: %s" % (`srcname`, `dstname`, str(why))

def handle_remove_readonly(func, path, exc):
  """Remove error handler. change file permission and retry delete."""
  excvalue = exc[1]
  if func in (os.rmdir, os.remove):
    os.chmod(path, stat.S_IRWXU| stat.S_IRWXG| stat.S_IRWXO)
    func(path)
  else:
    raise

def extract_vba(tmpdir, filename):
  """Extract vba file."""
  with open(filename, "rb") as f:
    lines = f.read().split("\n")[3:]
  while len(lines) > 0:
    name = lines.pop(0).split("\t")[0]
    if len(name) == 0:
      break
    td = os.path.dirname(name)
    if len(td) == 0:
      continue
    if not os.path.isdir(td):
      os.makedirs(td)
    count = int(lines.pop(0))
    data = "\n".join(lines[0:count])
    lines = lines[count:]
    with open(name, "wb") as f:
      f.write(data)

def extract_tar_gz(tmpdir, filename):
  """Extract tar.gz/tar.bz2 file."""
  with tarfile.open(filename) as tfile:
    parent_dir = tfile.getmembers()[0].name.split("/")[0]
    has_parent = parent_dir in ["autoload", "colors", "compiler", "doc", "ftplugin", "indent", "keymap", "plugin", "syntax"]
    for tinfo in tfile.getmembers():
      tf = tinfo.name
      if not has_parent:
        tf = "/".join(tf.split("/")[1:])
      td = os.path.dirname(tf)
      if len(td) == 0:
        continue
      if not os.path.isdir(td):
        os.makedirs(td)
      with open(tf, "wb") as f:
        f.write(tfile.extractfile(tinfo.name).read())

def extract_zip(tmpdir, filename):
  """Extract zip file."""
  with zipfile.ZipFile(filename, 'r') as zfile:
    parent_dir = zfile.infolist()[0].filename.split("/")[0]
    has_parent = parent_dir in ["autoload", "colors", "compiler", "doc", "ftplugin", "indent", "keymap", "plugin", "syntax"]
    for zinfo in zfile.infolist():
      zf = zinfo.filename
      if not has_parent:
        zf = "/".join(zf.split("/")[1:])
      zd = os.path.dirname(zf)
      if len(zd) == 0:
        continue
      if not os.path.isdir(zd):
        os.makedirs(zd)
      with open(zf, "wb") as f:
        f.write(zfile.read(zinfo.filename))

def command_uninstall(name):
  """Delete files writen in meta-info."""
  info = get_record(name)
  if not info:
    print >>sys.stderr, "%s is not installed" % name
    return
  home = get_vimhome()
  for f in info["files"]:
    ff = os.path.join(home, f)
    if os.path.exists(ff):
      os.remove(ff)
  delete_record(name)

def invoke_custom_installer(tmpdir, info):
  """Run custom installer shell(or batch file)."""
  if sys.platform == 'win32':
    with open(os.path.join(tmpdir, "___install.bat"), "wb") as f:
      f.write("@echo off\n")
      f.write(info["installer_win32"])
    os.system("___install.bat")
    os.remove("___install.bat")
  else:
    with open(os.path.join(tmpdir, "___install.sh"), "wb") as f:
      f.write(info["installer_unix"])
      f.write(info["installer_unix"])
    os.system("sh ___install.sh")
    os.remove("___install.sh")

def command_install(name):
  """Install from remote."""
  if isinstance(name, dict):
    info = name
    name = info["name"]

  if len(name) > 4 and name.startswith("git!"):
    url = name[4:]
    name = urlparse(url).path.split("/").pop()
    info = {
      "name": name,
      "url": url,
      "author": "unknown",
      "description": "%s via %s" % (name, url),
      "version": "unknown",
      "packer": "unknown",
      "requires": "unknown",
      "extractor": "git",
      "installer": "",
    }
  elif len(name) > 4 and name.startswith("svn!"):
    url = name[4:]
    name = urlparse(url).path.split("/").pop()
    info = {
      "name": name,
      "url": url,
      "author": "unknown",
      "description": "%s via %s" % (name, url),
      "version": "unknown",
      "packer": "unknown",
      "requires": "unknown",
      "extractor": "svn",
      "installer": "",
    }
  elif len(name) > 7 and name.startswith("http://"):
    name = urlparse(url).path.split("/").pop()
    info = {
      "name": name,
      "url": url,
      "author": "unknown",
      "description": "%s via %s" % (name, url),
      "version": "unknown",
      "packer": "unknown",
      "requires": "unknown",
      "extractor": "",
      "installer": "",
    }
  else:
    info = get_joltinfo(name)
  if not info:
    print >>sys.stderr, "Jolt not installed"
    return

  tmpdir = tempfile.mkdtemp()
  olddir = os.getcwd()
  try:
    os.chdir(tmpdir)

    if info["extractor"] == "git":
      os.system("git clone --depth=1 %s %s" % (info["url"], tmpdir))
      shutil.rmtree(os.path.join(tmpdir, ".git"), ignore_errors=False, onerror=handle_remove_readonly)
      # TODO: fix behavior when it's not general vim's runtime path structure.
    elif info["extractor"] == "svn":
      os.system("svn export %s %s" % (info["url"], tmpdir))
    else:
      f = urllib2.urlopen(info["url"])
      filename = f.info()["Content-Disposition"].split("filename=")[1]
      with open(filename, "wb") as f:
        f.write(r.read())

      if filename.endswith(".vba"):
        extract_vba(tmpdir, filename)
        os.remove(filename)
      elif filename.endswith(".vba.gz"):
        with open(filename[:-3], "wb") as f:
          with gzip.open(filename) as gz:
            f.write(gz.read())
        os.remove(filename)
        filename = filename[:-3]
        extract_vba(tmpdir, filename)
        os.remove(filename)
      elif filename.endswith(".tar.gz") or filename.endswith(".tar.bz2"):
        extract_tar_gz(tmpdir, filename)
        os.remove(filename)
      elif filename.endswith(".zip"):
        extract_zip(tmpdir, filename)
        os.remove(filename)
      elif info["installer"] in ["plugin", "ftplugin", "syntax", "colors", "doc", "indent", "dict"]:
        os.makedirs(os.path.join(tmpdir, info["installer"]))
        shutil.move(filename, os.path.join(tmpdir, info["installer"], filename))
      elif info["installer"] == "custom":
        invoke_custom_installer(tmpdir, info)

    copytree(tmpdir, get_vimhome(), tmpdir)
    filelist = []
    for root, subdirs, files in os.walk(tmpdir):
      for f in files:
        filelist.append(re.sub("\\\\", "/", os.path.relpath(os.path.join(root, f), tmpdir)))
    info["files"] = filelist

    add_record(name, info)

  except RuntimeError, e:
    print >>sys.stderr, "Exception occured in %s" % tmpdir
    traceback.print_exc()
  finally:
    os.chdir(olddir)
    shutil.rmtree(tmpdir)

def command_joltinfo(name):
  """Show jolt-info getting from vimjolts server."""
  info = get_joltinfo(name)
  if not info:
    print >>sys.stderr, "Jolt not installed"
    return
  print "\n".join([
    "Name: %s" % info["name"],
    "Version: %s" % info["version"],
    "Description: %s" % info["description"],
    "URL: %s" % info["url"],
    "Packer: %s" % str(info["packer"]),
    "Requires:\n  %s" % "\n  ".join(info["requires"])])

def command_search(word):
  """Search the name of package from vimjolts server."""
  f = urllib2.urlopen("http://vimjolts.appspot.com/api/search?" + urllib.urlencode({"word": word}))
  res = simplejson.load(f)
  for r in res:
    print "%s: %s" % (r["name"], r["version"])

def command_list():
  """Show the names of installed packages."""
  metadir = os.path.join(get_vimhome(), "jolts", ".meta")
  if not os.path.isdir(metadir):
    return
  metafiles = os.listdir(metadir)
  for f in metafiles:
    info = get_record(f)
    if info:
      print "%s: %s" % (f, info["version"])

def command_update():
  """Update all packages installed."""
  metadir = os.path.join(get_vimhome(), "jolts", ".meta")
  if not os.path.isdir(metadir):
    return
  metafiles = os.listdir(metadir)
  for f in metafiles:
    print "updating %s ..." % f
    info = get_record(f)
    if info:
      command_install(info)
    else:
      command_install(f)

def command_metainfo(name):
  """Show meta-info of installed package."""
  info = get_record(name)
  if not info:
    print >>sys.stderr, "%s is not installed" % name
    return
  print "\n".join([
    "Name: %s" % info["name"],
    "Version: %s" % info["version"],
    "Description: %s" % info["description"],
    "URL: %s" % info["url"],
    "Packer: %s" % str(info["packer"]),
    "Requires:\n  %s" % "\n  ".join(info["requires"]),
    "Files:\n %s" % "\n  ".join(info["files"])])

def command_help():
  """Show command usages."""
  print """
Jolt : the Vim Package Management System
    your vim home: %s

  commands:
    list:                 list installed packages.
    update:               update all old plugins.
    joltinfo  [package]:  show information of the package via joltserver
    metainfo  [package]:  show information of the package via local cache
    install   [package]:  install the package.
    uninstall [package]:  uninstall the package.
    search    [word]:     search packages from joltserver
""" % get_vimhome()
  sys.exit(0)

if __name__ == '__main__':
  if len(sys.argv) == 1:
    command_help()
  commands = {
    "help":       command_help,
    "install":    command_install,
    "joltinfo":   command_joltinfo,
    "list":       command_list,
    "metainfo":   command_metainfo,
    "search":     command_search,
    "uninstall":  command_uninstall,
    "update":     command_update,
  }
  if sys.argv[1] not in commands:
    print >>sys.stderr, sys.argv[1] + ": unknown command"
    command_help();
  try:
    commands[sys.argv[1]](*sys.argv[2:])
  except KeyboardInterrupt:
    pass
  except:
    if sys.argv[1] != "help":
      traceback.print_exc()
    sys.exit(1)

# vim:set et ts=2 sw=2:
